<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module wrangler</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module wrangler</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module describes the refactorings that are currently supported by Wrangler.
<p>Copyright © 2006-2009 Huiqing Li, Simon Thompson
 </p>

<p><b>Version:</b> 0.6.2</p>
<p><b>Authors:</b> Huiqing Li, Simon Thompson [<em>web site:</em> <tt><a href="http://www.cs.kent.ac.uk/projects/forse" target="_top">http://www.cs.kent.ac.uk/projects/forse</a></tt>].</p>

<h2><a name="description">Description</a></h2>This module describes the refactorings that are currently supported by Wrangler.
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_a_tag-5">add_a_tag/5</a></td><td>Add a tag to all the messages received by a server process.</td></tr>
<tr><td valign="top"><a href="#duplicated_code_in_buffer-3">duplicated_code_in_buffer/3</a></td><td>A duplicated code detector that only works with the current Erlang buffer.</td></tr>
<tr><td valign="top"><a href="#duplicated_code_in_dirs-3">duplicated_code_in_dirs/3</a></td><td>A duplicated code detector that works with multiple Erlang modules.</td></tr>
<tr><td valign="top"><a href="#expression_search-3">expression_search/3</a></td><td>Search for clones of an expression/expression sequence selected in the current file.</td></tr>
<tr><td valign="top"><a href="#fold_against_macro-4">fold_against_macro/4</a></td><td>Fold expressions/patterns against a macro definition.</td></tr>
<tr><td valign="top"><a href="#fold_expr-1">fold_expr/1</a></td><td>Fold expressions against a function definition.</td></tr>
<tr><td valign="top"><a href="#fun_extraction-4">fun_extraction/4</a></td><td>Introduce a new function to represent an expression or expression sequence.</td></tr>
<tr><td valign="top"><a href="#fun_to_process-5">fun_to_process/5</a></td><td>Turn a function into a server process.</td></tr>
<tr><td valign="top"><a href="#generalise-5">generalise/5</a></td><td> Generalise a function definition.</td></tr>
<tr><td valign="top"><a href="#move_fun-6">move_fun/6</a></td><td>Move a function definition from its current module to another.</td></tr>
<tr><td valign="top"><a href="#new_macro-5">new_macro/5</a></td><td>Introduce a macro to represent a syntactically well-formed expression/pattern or a sequence of expressions/patterns.</td></tr>
<tr><td valign="top"><a href="#register_pid-5">register_pid/5</a></td><td>Register a process.</td></tr>
<tr><td valign="top"><a href="#rename_fun-5">rename_fun/5</a></td><td>Rename a function with a new name supplied by the user.</td></tr>
<tr><td valign="top"><a href="#rename_mod-3">rename_mod/3</a></td><td>Rename a module with a new name supplied by the user.</td></tr>
<tr><td valign="top"><a href="#rename_mod_batch-3">rename_mod_batch/3</a></td><td>Rename a collection of modules in batch mode.</td></tr>
<tr><td valign="top"><a href="#rename_process-5">rename_process/5</a></td><td>Rename a registered process with a new name supplied by the user.</td></tr>
<tr><td valign="top"><a href="#rename_var-5">rename_var/5</a></td><td>Rename a variable with a new name supplied by the user.</td></tr>
<tr><td valign="top"><a href="#tuple_funpar-5">tuple_funpar/5</a></td><td>Turn some consecutive parameters of a function into a tuple parameter.</td></tr>
<tr><td valign="top"><a href="#tuple_to_record-8">tuple_to_record/8</a></td><td>From tuple to record representation.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_a_tag-5">add_a_tag/5</a></h3>
<div class="spec">
<p><tt>add_a_tag(Filename::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), Tag::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, [<a href="#type-filename">filename()</a>]}</tt></p>
</div><p>Add a tag to all the messages received by a server process.
  <p> This refactoring should be initiated from the main receive function of a server process.
  The current implementation is still in an experimental stage, and has a number of limitations:
  <li> The current implementation assumes that the process does not send enquiries,
       using the <code> send ... receive </code> pattern, to other processes
  </li>
  <li> The current implementation only handles processes spawned using <code>spawn</code>
       or <code>spawn_link</code>
  </li>
  </p>
 <p>
  Usage: to apply this refactoring, point the cursor to the function name, then select <em> Add a
  Tag to Messages </em> from the <em> Refactor </em> menu, Wrangler will then prompt to
  enter the tag.
 </p></p>

<h3 class="function"><a name="duplicated_code_in_buffer-3">duplicated_code_in_buffer/3</a></h3>
<div class="spec">
<p><tt>duplicated_code_in_buffer(FileName::<a href="#type-filename">filename()</a>, MinToks::integer(), MinClones::integer()) -&gt; {ok, string()}</tt></p>
</div><p>A duplicated code detector that only works with the current Erlang buffer.
  <p> This function reports duplicated code fragments found in the current Erlang buffer, it does
  not remove those code clones though. The user will be prompted for two parameters: the minimum number of
  tokens a cloned code fragment should have, and the minimum number of times a code fragment appears in the program.
  </p>
  <p> The current version of the duplicated code detector reports clones that are syntactically
  identical after consistent renaming of variables, except for variations in literals, layout and comments.
  </p>
  <p>
  Usage: simply select the  <em> Detect Duplicated Code in Current Buffer </em> from the <em> Refactor </em> sub-menu,
  Wrangler will prompt to input the parameters.
  </p></p>

<h3 class="function"><a name="duplicated_code_in_dirs-3">duplicated_code_in_dirs/3</a></h3>
<div class="spec">
<p><tt>duplicated_code_in_dirs(FileNameList::[<a href="#type-filename">filename()</a> | <a href="#type-dir">dir()</a>], MinToks::string(), MinClones::string()) -&gt; {ok, string()}</tt></p>
</div><p>A duplicated code detector that works with multiple Erlang modules.
  <p> This function reports duplicated code fragments found in the directories specified by SearchPaths, it does
  not remove those code clones though.
  The user will be prompted for two parameters: the minimum number of
  tokens that a cloned code fragment should have, and the minimum number of times a code fragment appears in the program.
  </p>
  <p> The current version of the duplicated code detector reports clones that are syntactically
  identical after consistent renaming of variables, except for variations in literals, layout and comments.
  </p>
  <p>
  Usage: first check the SearchPaths specificed in the customisation page to make sure that the directory (or directories) specified is
  the place where you want to search for duplicated code, then select <em> Detect Duplicated Code in Dirs </em> from the
  <em> Refactor </em> sub-menu, Wrangler will then prompt to input the parameters.
  </p></p>

<h3 class="function"><a name="expression_search-3">expression_search/3</a></h3>
<div class="spec">
<p><tt>expression_search(FileName::<a href="#type-filename">filename()</a>, Start::Pos, End::Pos) -&gt; {ok, [{integer(), integer(), integer(), integer()}]} | {error, string()}</tt></p>
</div><p><p>Search for clones of an expression/expression sequence selected in the current file.</p>
 
  <p> This functionality allows searching for clones of a selected expression or expression
  sequence.  The found clones are syntactically identical to the code fragment selected  after consistent renaming of variables,
  except for variations in literals, layout and comments.
  </p>
  <p> When the selected code contains multiple, but non-continuous sequence of, expressions, the first
  continuous sequence of expressions is taken as the user-selected expression. A continuous sequence of
  expressions is a sequence of expressions separated by ','. </p>
  Usage: highlight the expression/expression sequence of interest, then selected  <em> Expression Search </em> from
  the <em> Refactor </em> sub-menu.</p>

<h3 class="function"><a name="fold_against_macro-4">fold_against_macro/4</a></h3>
<div class="spec">
<p><tt>fold_against_macro(FileName, Line, Col, SearchPaths) -&gt; any()</tt></p>
</div><p>Fold expressions/patterns against a macro definition.
  <p>
  This refactoring replaces instances of the right-hand side of a macro definition by the corresponding
  left-hand side with necessary parameter substitutions.
  </p>
  <p> To apply this refactoring, first point the cursor to the macro definition against which candidate
   expressions/candidates will be folded; then select <em> Fold Against Macro Definition </em> from the
  <em> Refactor </em> menu; after that, Wrangler will search the current module for expressions/patterns
  which are instances of the right-hand side of the selected macro definition; and direct you through the
  refactoring process.
  </p></p>

<h3 class="function"><a name="fold_expr-1">fold_expr/1</a></h3>
<div class="spec">
<p><tt>fold_expr(X1::{{FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), SearchPaths::[<a href="#type-dir">dir()</a>]} | {FileName::<a href="#type-filename">filename()</a>, ModName::<a href="#type-modulename">modulename()</a>, Arity::integer(), ClauseIndex::integer(), SearchPaths::[<a href="#type-dir">dir()</a>]}}) -&gt; {ok, [{{{integer(), integer()}, {integer(), integer()}}, <a href="#type-syntaxTree">syntaxTree()</a>}]} | {error, string()}</tt></p>
</div><p>Fold expressions against a function definition.
  <p>
  This refactoring replaces instances of the right-hand side of a function clause definition by
  the corresponding left-hand side with necessary parameter substitutions. The function clause can
  be defined in either the current module or another module.
  </p>
  <p> In the case that a candidate expression/expression sequence  needs to export some variables which
  are used by the code following code, that expression/expression sequence will be replaced by a match
  expression, whose left-hand side it the exported variable(s), and right-hand side is the function
  application.
 </p>
  <p> This refactoring does not support folding against function clauses with guard expressions, or
  function clauses with complex formal parameters, such as tuples, lists, or records.
  </p>
  <p> Usage: first point the cursor to the function clause against which expressions will be
  folded if the function is defined in the current module, or leave the cursor anywhere if you would like to
  fold against a function clause defined in another module; then select <em> Fold Expression Against Function </em>
  from the <em> Refactor </em> menu; after that, Wrangler then asks to confirm that you want to fold against
  the function clause pointed to by the cursor, if you answer 'no', Wrangler will prompt to provide the
  module name, function name ,arity of the function and the index of the function clause (starting from 1). After all these initial interaction,
  Wrangler will search
  the current module for expressions which are instances of the right-hand side of the selected function clause.
  </p>
  <p> If no candidate expression has been found, a message will be given, and the refactoring
  finishes; otherwise, Wrangler will go through the found candidate expressions one by one, and ask
  the user whether she/he wants to replace the expression with an application of selected function.
  If the user answers 'yes' to one instance,  that instance will be replaced by function application,
  otherwise it will remain unchanged.
  </p></p>

<h3 class="function"><a name="fun_extraction-4">fun_extraction/4</a></h3>
<div class="spec">
<p><tt>fun_extraction(FileName::<a href="#type-filename">filename()</a>, Start::Pos, End::Pos, FunName::string()) -&gt; {error, string()} | {ok, string()}</tt></p>
</div><p>Introduce a new function to represent an expression or expression sequence.
  <p> This refactoring allows the user to introduce a new function to represent a selected expression or expression
  sequence, and replace the selected code with a call to the new function.  Free variables
  within the selected code become the formal parameters of the function definition.
  </p>
  <p>
  Usage: highlight the expression/expression sequence of interest, then selected the <em>Function Extraction</em>
  from the <em>Refactor</em> sub-menu, Wrangler will then prompt for the new function name.
  </p></p>

<h3 class="function"><a name="fun_to_process-5">fun_to_process/5</a></h3>
<div class="spec">
<p><tt>fun_to_process(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), ProcessName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {ok, [<a href="#type-filename">filename()</a>]} | {error, string()}</tt></p>
</div><p>Turn a function into a server process.
 <p>
  This refactoring turns a function into a server process, and all the function calls to this function into process communication.
  Turning a function into a server process provides potential for memorisation of calculated values, adding states to the process, etc.
  </p>
  <p> The following example shows the application of this refactoring to the function <code>f/2</code> on the
  left-hand side, and the result is shown on the right-hand side.
 
     <pre>         f(add,X,Y) -&gt; X +Y;                        f_rpc(RegName, Request) -&gt;
         f(sub,X,Y) -&gt; X - Y.                            Fun = fun() -&gt;
                                                                     try
         g(X, Y) -&gt;                                                     register(RegName, self())
             f(add, X,Y)*f(sub, X, Y).                               catch
                                                                        true -&gt; f();
                                                                        error:_ -&gt; already_running
                                                                     end
                                                               end,
                                                         Spawn(Fun),
                                                         RegName ! {self(), Request},
                                                         receive {RegName, Response} -&gt; Response end.
 
                                                    f() -&gt;
                                                       receive
                                                          {From, {add, X, Y}} -&gt; From ! {f, X + Y}, f();
                                                          {From, {sub, X, Y}} -&gt; From ! {f, X - Y}, f()
                                                       end.
 
                                                    g(X, Y) -&gt;
                                                       f_rpc(f, {add, X, Y}) * f_rpc(f, {sub, X, Y}).</pre>
  </p>
  The following side-conditions apply to this refactoring:
  <p>
  <li> The process name provided by the user should be lexically legal, and not conflict with existing process names. </li>
  <li> The function should not be a recursive function, either directly or indirectly. </li>
  <li> The current function or functions called by this function should not register the <code>Pid</code> returned by <code>self()</code>. </li>
  </p>
  <p>
  Wrangler generates the new function name and the rpc function name automatically, but the user could always rename it afterwards.
  Suppose the original function is <code>f/n</code>, then the new function name would be <code>f/0</code> and the <code>rpc</code>
  function name would be <code>f_rpc/2</code>; if any conflicts occur, <code>'_i'</code> will be attached to the end of the function
  name where <code>i</code> is a smallest number that makes the name fresh.
  </p>
  <p> To apply this refactoring, point the cursor to the function of interest, then select
  <em> From Function to Process </em> from the <em> Refactor </em> sub-menu, after that, Wrangler will prompt
   to enter the process registration name  in the mini-buffer.
  </p></p>

<h3 class="function"><a name="generalise-5">generalise/5</a></h3>
<div class="spec">
<p><tt>generalise(FileName::<a href="#type-filename">filename()</a>, Start::Pos, End::Pos, ParName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {ok, string()} | {error, string()}</tt>
<ul class="definitions"><li><tt>Pos = {integer(), integer()}</tt></li>
</ul></p>
</div><p> Generalise a function definition.
  <p>Generalise a function definition by selecting a sub-expression of its right-hand
  side and making this the value of a new argument added to the definition of the function.
  The sub-expression becomes the actual parameter at the call sites. </p>
 
  <p> Here is an example of generalisation, in which the function <code> add_one </code> defined
  on the left-hand side is generalised on the expression <code> 1 </code>, and the result is
  shown on the right-hand side.
 
         <pre>                -module (test).                          -module (test).
                -export([f/1]).                          -export([f/1]).
 
                add_one ([H|T]) -&gt;                       add_one (N, [H|T]) -&gt;
                   [H+1 | add_one(T)];                      [H+N | add_one(N,T)];
                add_one ([]) -&gt; [].                      add_one (N, []) -&gt; [].
 
                f(X) -&gt; add_one(X).                      f(X) -&gt; add_one(1,X)</pre>
   </p>
 
  <p> In the case that the selected expression has a side-effect, the refactorer will wrap this expression
  in an function expression before passing it as the actual parameter to the call-sites. This is illustrated
  in the following example, in which function <code>repeat/1</code> is generalised on the expression
  <code>io:format("Hello\n")</code>.
 
          <pre>                -module (test).                          -module (test).
                -export([f/0]).                          -export([f/0]).
 
                repeat(0) -&gt; ok;                         repeat(A, 0) -&gt; ok;
                repeat(N) -&gt;                             repeat(A, N) -&gt;
                  io:format("Hello\n"),                    A( ),
                  repeat(N-1).                             repeat(A,N-1).
 
                f() -&gt; repeat(5).                        f( ) -&gt;
                                                            repeat (fun( )-&gt;io:format ("Hello\n") end, 5).</pre>
  </p>
 
  <p> This refactoring <em>only </em> affects the module in which the refactoring is initialised. In the case that
  the generalised function is exported by the module, an auxiliary function will be created
  to wrap the generalised function up, so that the module's interface is not changed.
  </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> Suppose the function to be generalised is <code>foo/n </code>, then <code>foo/n+1</code> should not
  be in scope before the generalisation;</li>
  <li> The new parameter name provided by the user should not conflict with the existing parameters or
  change the semantics of the function to be generalised. </li>
  </p>
  <p> Usage: to apply this refactoring, highlight the expression first, then  select
  <em> Generalise Function Definition </em> from the <em>Refactor</em> menu, after
  that the refactorer will prompt to enter the parameter name in the mini-buffer. </p>
 </p>

<h3 class="function"><a name="move_fun-6">move_fun/6</a></h3>
<div class="spec">
<p><tt>move_fun(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), TargetModName::string(), CreateNewFile::<a href="#type-boolean">boolean()</a>, SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {ok, [<a href="#type-filename">filename()</a>]} | {error, string()}</tt></p>
</div><p>Move a function definition from its current module to another.
  <p> This refactoring has a global effect, i.e., it affects all the modules in which
      the function is imported/used.
  </p>
  <p> This refactoring assumes that an Erlang module name always matches its file name.
  </p>
  <p> Suppose we move function <em> foo/n </em> from its current module <em> M </em>
      to module <em> N </em>, then the following <em> side-conditions </em> apply to
      this refactoring:
  <li> If <em> foo/n </em> is already in scope in module <em> N </em>, then its defining
       module should be  <em> M </em>.
  </li>
  <li> Function <em> foo/n </em> should not contain any uses of <em> implicit fun expressions </em> (Note: move a
  collection of functions together to another module will be supported by another refactoring).
  </li>
  </p>
  <p> Usage: to apply this refactoring, point the cursor at the function definition, then
  select <em> Move Definition to Another Module</em> from the <em> Refactor </em> menu,
  Wrangler will then  prompt to enter the target module name in the mini-buffer.
  </p></p>

<h3 class="function"><a name="new_macro-5">new_macro/5</a></h3>
<div class="spec">
<p><tt>new_macro(FileName::<a href="#type-filename">filename()</a>, Start::<a href="#type-pos">pos()</a>, End::<a href="#type-pos">pos()</a>, NewMacroName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, string()}</tt></p>
</div><p>Introduce a macro to represent a syntactically well-formed expression/pattern or a sequence of expressions/patterns.
  <p> This refactoring allows the user to define a new macro to represent a expression/pattern or sequence of
  of expressions/patterns selected by the user, and replace the selected code with an application of the macro.
  Free variables within the selected code become the formal parameters of the macro definition.
  </p></p>

<h3 class="function"><a name="register_pid-5">register_pid/5</a></h3>
<div class="spec">
<p><tt>register_pid(Filename::<a href="#type-filename">filename()</a>, Start::<a href="#type-pos">pos()</a>, End::<a href="#type-pos">pos()</a>, RegName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, [<a href="#type-filename">filename()</a>]}</tt></p>
</div><p>Register a process.
  <p>This refactoring registers a process id, <code>Pid</code> say, with a name, regname say, and replaces
  the uses of <code>Pid ! Msg </code> with  <code>regname ! Msg</code> whenever it is possible.
  </p>
  <p>
  The following side-conditions apply to this refactoring:
  <li> The process name provided by the user should be lexically valid.</li>
  <li>  The name provided by the user should not have been used as a process name. </li>
  <li> The process under consideration should not have been registered. </li>
  <li> Only one process spawned by the spawn expression selected should exist anytime during the running of the system. </li>
  </p>
  <p>
  Usage: First select a match expression whose left-hand side is a process identifier, and right-hand side is a spawn expression,
  then select <em> Register a Process</em> command from the <em>Refactor</em> menu, after that, Wrangler will prompt for the
  process name.
  </p></p>

<h3 class="function"><a name="rename_fun-5">rename_fun/5</a></h3>
<div class="spec">
<p><tt>rename_fun(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), NewName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, [<a href="#type-filename">filename()</a>]}</tt></p>
</div><p>Rename a function with a new name supplied by the user.
  <p>
  When renaming an exported function, this refactoring has a global effect, that is,
  it affects all those modules in which this function is imported/used.
  </p>
  <p> The following <em> side-conditions </em> (or <em>pre-conditions </em>}  apply to this refactoring:
  <li> The new function name should not cause confliction with any of the functions which are in scope in the
  current module;</li>
  <li> In the case that the function to be renamed is imported by another module, the new function name (with the same
  arity) should not be already in scope (either defined or imported) in that module. </li>
  </p>
  <p> Usage: to apply this refactoring, point the cursor to any occurrence of this
  function name, then select <em> Rename Function Name </em> from the <em> Refactor </em> menu,
  after that, Wrangler will prompt to enter  the new function name in the mini-buffer.
  </p></p>

<h3 class="function"><a name="rename_mod-3">rename_mod/3</a></h3>
<div class="spec">
<p><tt>rename_mod(FileName::<a href="#type-filename">filename()</a>, NewName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, [<a href="#type-filename">filename()</a>]}</tt></p>
</div><p>Rename a module with a new name supplied by the user.
  <p> This refactoring affects all those modules in which the module name is used.
  </p>
  <p>
  The following <em> side-conditions </em> apply to this refactoring:
  <li> The new module name should not have been used as a module name in the program under consideration. </li>
  <li> This refactoring assume that the file basename is always the same as the module name, therefore this
  refactoring changes the filename as well. </li>
  </p>
  <p> Usage: to apply this refactoring, point the cursor anywhere in the module to be renamed, then select
  <em> Rename Module Name </em> from the <em> Refactor </em> menu, after that, the refactorer will prompt to enter
  the new module name in the mini-buffer.
  </p></p>

<h3 class="function"><a name="rename_mod_batch-3">rename_mod_batch/3</a></h3>
<div class="spec">
<p><tt>rename_mod_batch(OldNamePattern::string(), NewNamePattern::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {ok, string()} | {error, string()}</tt></p>
</div><p>Rename a collection of modules in batch mode.
  <p> This refactoring has a global effect. </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> The new module names should not conflict with each other, or any existing module names
  in the same scope which will not be renamed. </li>
  <li> This refactoring assumes that the file basename is always the same as the module name, therefore
  filenames will be changed along with module names. </li>
  </p>
  <p> Usage: this refactoring is supposed to be run from the Erlang shell. For example,
  to rename all those module names which match the regular expression "foo_*" to
  "foo_*_1_0" in the directory <code> c:/wrangler/test </code>, just type the following command:
  <code> wrangler:rename_mod_batch("foo_*, "foo_*_1_0", ["c:/wrangler/test"]) </code>.
  </p></p>

<h3 class="function"><a name="rename_process-5">rename_process/5</a></h3>
<div class="spec">
<p><tt>rename_process(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), NewName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {undecidables, string()} | {ok, [<a href="#type-filename">filename()</a>]}</tt></p>
</div><p>Rename a registered process with a new name supplied by the user.
  <p> To apply this refactoring, point the cursor to the process name, then select
  <em> Rename a Process </em> from the  <em> Refactor </em> menu, after that, Wrangler will prompt
  to enter the new process name in the mini-buffer.
  </p>
  <p> This refactoring has a global effect, i.e. it needs to check the whole program for places where the
  original process name is used.
  </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> The new process name should not be the atom 'undefined' </li>
  <li> The new process name should not have been used as a process name in the program under consideration.  </li>
  <li> Since there are some cases where Wrangler cannot infer whether an atom represents a process name or not, for example,
  a process name in a message, it would be help the refactoring process to select the process name from expressions, such as
  registration expressions, where it is easier for Wrangler to infer that the atom is a process name.</li>
  </p></p>

<h3 class="function"><a name="rename_var-5">rename_var/5</a></h3>
<div class="spec">
<p><tt>rename_var(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), NewName::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, string()}</tt></p>
</div><p>Rename a variable with a new name supplied by the user.
  <p> This refactoring has a local effect, i.e., it only affects the function clause in which the refactoring is initialised.
  </p>
  <p> The following <em> side-conditions </em> (or <em>pre-conditions</em>) apply to this refactoring:
  <li> The new variable name should not conflict with any of the declared variable names in the same scope;</li>
  <li> The new variable name should not shadow any of the existing variables in the outer scopes, or be shadowed by any of
  of existing variables in the inner scopes, i.e., renaming to the new name should not change the semantics of the
  program.</li>
  </p>
  <p> Usage: to apply this refactoring, point the cursor to any occurrence of this variable, then select
  <em> Rename Variable Name </em> from the <em> Refactor </em> sub-menu, after that, Wrangler will prompt
  to enter the new variable name in the mini-buffer.
  </p></p>

<h3 class="function"><a name="tuple_funpar-5">tuple_funpar/5</a></h3>
<div class="spec">
<p><tt>tuple_funpar(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), Number::string(), SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, [<a href="#type-filename">filename()</a>]}</tt></p>
</div><p>Turn some consecutive parameters of a function into a tuple parameter.
  <p>
  When the function under consideration is exported by the module where it is defined, this refactoring has a global effect.
  </p>
  <p> Suppose the new function after refactoring is <code>f/n</code>, then the following <em> side-conditions </em> apply:
  <li> <code> f/n</code> should not cause confliction with any of the functions which are in scope in the
  current module;</li>
  <li> In the case that the function is imported by another module, then <code>f/n</code>
  should not be already in scope (either defined or imported) in that module. </li>
  </p>
  <p> Usage: to apply this refactoring, point the cursor to the parameter which is going to be the first
  element of the tuple, then select <em> Tuple Function Arguments </em> from the <em> Refactor </em> sub-menu,
  after that, Wrangler will prompt to enter the number of parameters to include into the tuple in the minibuffer.
  </p></p>

<h3 class="function"><a name="tuple_to_record-8">tuple_to_record/8</a></h3>
<div class="spec">
<p><tt>tuple_to_record(File::<a href="#type-filename">filename()</a>, FLine::integer(), FCol::integer(), LLine::integer(), LCol::integer(), RecName::string(), FieldString::[string()], SearchPaths::[<a href="#type-dir">dir()</a>]) -&gt; {error, string()} | {ok, [<a href="#type-filename">filename()</a>]}</tt></p>
</div><p>From tuple to record representation.
   NOTE: this refactoring is still in an experimental stage.
  <p>
  This refactoring has a global effect, i.e., it affects all those modules in
  which this function is imported/used.
  </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> The record and field names must be lexically legal; </li>
  <li> The number of record fields must equal to the selected tuple size; </li>
  <li> The function must be defined in the current module; </li>
  <li> The selected part must be a tuple.  </li>
  </p>
  <p> To apply this refactoring, highlight the tuple, which should be a function parameter,
  then select <em> From Tuple To Record </em> from the <em> Refactor </em>  sub-menu,
  Wrangler will then prompt to enter the record name and  the record field names.
  </p></p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Feb 3 2009, 09:45:11.</i></p>
</body>
</html>
