<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Automatic behaviour inference</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/" target="_top"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<h1>Automatic behaviour inference</h1>
<p>Copyright Â© (C) 2015 Pablo Lamela, Simon Thompson</p>
<p><b>Authors:</b> Pablo Lamela Seijas (<a href="mailto:P.Lamela-Seijas@kent.ac.uk"><tt>P.Lamela-Seijas@kent.ac.uk</tt></a>), Simon Thompson (<a href="mailto:S.J.Thompson@kent.ac.uk"><tt>S.J.Thompson@kent.ac.uk</tt></a>).</p>


<p>This package provides a mechanism that automatically creates an Erlang behaviour by merging two modules selected by the user, which are assumed to be structurally similar, and possibly the result of copying and modifying one of them to produce the other.</p>

<p>The algorithm consists of four main stages:</p>

<ul>
  <li>Tree matching (<a href="tree_mapping.html"><code>tree_mapping</code></a>) - Compares the ASTs of the two input modules</li>
  <li>Cluster construction (<a href="tree_clustering.html"><code>tree_clustering</code></a>) - Divides the contiguous mapped subtrees into clusters</li>
  <li>Cluster linking (<a href="cluster_linking.html"><code>cluster_linking</code></a>) - Organises and links the clusters so that the order of execution from the original ASTs is preserved</li>
  <li>Rendering (<a href="cluster_mapping.html"><code>cluster_mapping</code></a>) - Uses the information about clusters and links to construct the three final ASTs</li>
</ul>

<p>The process starts with two modules which are assumed to be similar. First we find commonalities between their ASTs, group the contiguous commonalities, move the commonalities to a separate module, and link the pieces together with function calls in order to preserve the original behaviour. This way we are left with three modules: the remains of the original ones and a new module with the common parts. The module with the common code will be configured as a behaviour definition, and modules with the remainings of the original ones will be configured as behaviour instances of the new module.</p>

<p>The top level module for the algorithm is <a href="infer_behaviour.html"><code>infer_behaviour</code></a>.</p>

<img src="modulegraph.png" alt="Module graph" style="width: 100%; min-width: 600px; max-width: 1444px">

<hr>
<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/" target="_top"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Nov 12 2015, 18:43:11.</i></p>
</body>
</html>
